<!-- livebook:{"persist_outputs":true} -->

# Dynamic update by reloading an updated Wasm file

```elixir
Mix.install([
  {:nx, "~> 0.5.0"},
  {:wasmtube, github: "kentaro/wasmtube", branch: :main}
])
```

<!-- livebook:{"output":true} -->

```
* Getting wasmtube (https://github.com/kentaro/wasmtube.git - origin/main)
remote: Enumerating objects: 987, done.        
remote: Counting objects: 100% (210/210), done.        
remote: Compressing objects: 100% (122/122), done.        
remote: Total 987 (delta 88), reused 170 (delta 59), pack-reused 777        
Resolving Hex dependencies...
Resolution completed in 0.072s
New:
  castore 0.1.22
  complex 0.5.0
  file_system 0.2.10
  jason 1.4.0
  nx 0.5.1
  rustler_precompiled 0.5.5
  telemetry 1.2.1
  wasmex 0.8.2
* Getting nx (Hex package)
* Getting wasmex (Hex package)
* Getting jason (Hex package)
* Getting file_system (Hex package)
* Getting rustler_precompiled (Hex package)
* Getting castore (Hex package)
* Getting complex (Hex package)
* Getting telemetry (Hex package)

17:42:56.750 [info] Compiling file system watcher for Mac...

17:42:57.970 [info] Done.
==> file_system
Compiling 7 files (.ex)
Generated file_system app
===> Analyzing applications...
===> Compiling telemetry
==> jason
Compiling 10 files (.ex)
Generated jason app
==> complex
Compiling 2 files (.ex)
Generated complex app
==> nx
Compiling 31 files (.ex)
Generated nx app
==> castore
Compiling 1 file (.ex)
Generated castore app
==> rustler_precompiled
Compiling 4 files (.ex)
Generated rustler_precompiled app
==> wasmex
Compiling 14 files (.ex)

17:43:05.368 [debug] Copying NIF from cache and extracting to /Users/antipop/Library/Caches/mix/installs/elixir-1.14.3-erts-13.1.4/990c64bba7acddd769d09cced2a837ca/_build/rpi4_prod/lib/wasmex/priv/native/libwasmex-v0.8.2-nif-2.16-aarch64-apple-darwin.so
Generated wasmex app
==> wasmtube
Compiling 4 files (.ex)
Generated wasmtube app
```

<!-- livebook:{"output":true} -->

```
:ok
```

## Sequence diagram of function call and dynamic update

To enable dynamic update, Wasmtube handles notification of file update and reloads the updated Wasm file. Below is the sequence of dynamic update.

<!-- livebook:{"break_markdown":true} -->

### Function call to Wasm runtime

<!-- livebook:{"break_markdown":true} -->

```mermaid
sequenceDiagram
  autonumber

  participant Deployer

  box IoT Device
    participant OS
    participant Elixir App
    participant Wasmtube
    participant Wasm Sandbox
  end

  Deployer ->> OS: deploys a Wasm file

  OS ->> Elixir App: starts the app

  Elixir App ->> Wasmtube: starts Wasmtube <br> worker
  Wasmtube ->> OS: reads the Wasm file
  Wasmtube ->> Wasm Sandbox: instantiates <br> Wasm sandbox <br>with the file

  par functions calls
    Elixir App ->> Wasmtube: calls a function
    Wasmtube ->> Wasm Sandbox: delegates the function
    Wasm Sandbox -->> Wasmtube: responds to the call
    Wasmtube -->> Elixir App: delegate the response
  end
```

<!-- livebook:{"break_markdown":true} -->

### Update the Wasm file

<!-- livebook:{"break_markdown":true} -->

```mermaid
sequenceDiagram
  autonumber

  participant Deployer

  box IoT Device
    participant OS
    participant Elixir App
    participant Wasmtube
    participant Wasm Sandbox
  end

  Deployer ->> OS: deploys a new <br> Wasm file
  OS ->> Wasmtube: notifies the file updated
  Wasmtube ->> OS: re-reads the updated Wasm file
  Wasmtube ->> Wasm Sandbox: re-instantiates <br> the sandbox <br> with the file

  Note over Elixir App, Wasm Sandbox: snip function call (same above)
```

## Prepare a worker to handle file update

You can use `Wasmtube.Worker` for dynamic update.

```elixir
watch_dir = "/Users/antipop/src/github.com/kentaro/elixir-ml-wasm/wasm"
old_wasm = "#{watch_dir}/to_be_updated.wasm"
new_wasm = "#{watch_dir}/update.wasm"

{:ok, worker_pid} = Wasmtube.Worker.start_link(wasm_file: old_wasm)
```

<!-- livebook:{"output":true} -->

```
{:ok, #PID<0.1268.0>}
```

## Prepare data to be processed by Wasm function

```elixir
{tensor, key} =
  Nx.Random.key(42)
  |> Nx.Random.normal(100, 30.0, shape: {60})

values =
  tensor
  |> Nx.to_list()
  |> Enum.map(&round/1)
```

<!-- livebook:{"output":true} -->

```
[127, 71, 110, 75, 140, 150, 44, 112, 119, 88, 88, 58, 34, 69, 59, 133, 124, 111, 121, 102, 91, 118,
 62, 122, 79, 77, 73, 82, 116, 153, 115, 139, 97, 111, 117, 81, 18, 100, 60, 118, 150, 47, 80, 159,
 109, 92, 106, 108, 106, 126, ...]
```

## Phase 1: Call a function of the Wasm binary

At first, confirm the version and file stats of the Wasm binary as below:

```elixir
old_version = worker_pid |> Wasmtube.Worker.version()
```

<!-- livebook:{"output":true} -->

```
0
```

```elixir
old_stat = old_wasm |> File.stat!()
```

<!-- livebook:{"output":true} -->

```
%File.Stat{
  size: 1915581,
  type: :regular,
  access: :read_write,
  atime: {{2023, 3, 3}, {17, 55, 51}},
  mtime: {{2023, 3, 3}, {17, 55, 48}},
  ctime: {{2023, 3, 3}, {17, 55, 48}},
  mode: 33261,
  links: 1,
  major_device: 16777231,
  minor_device: 0,
  inode: 18968372,
  uid: 502,
  gid: 20
}
```

Then, call a function of the Wasm binary. Here we get a wrong result due to a wrong code intentionally added.

```elixir
old_result =
  worker_pid
  |> Wasmtube.Worker.call_function(
    :to_be_updated,
    data: %{
      values: values
    }
  )
```

<!-- livebook:{"output":true} -->

```
%{"mean" => 101, "median" => 0}
```

## Phase 2: Call a function of the newly updated Wasm binary

Wasmtube handles notification of file update caused by modification and metadata changes. Here we realize such a file update by just overwrite the old file by `File.copy!/2`. In a real case, a new file will be uploaded from some other machine (e.g. cloud or build machine).

```elixir
File.copy!(new_wasm, old_wasm)
```

<!-- livebook:{"output":true} -->

```
1915605
```

Confirm the version and file stats of the newly updated Wasm binary as below:

```elixir
new_version = worker_pid |> Wasmtube.Worker.version()
```

<!-- livebook:{"output":true} -->

```
1
```

```elixir
new_stat = old_wasm |> File.stat!()
```

<!-- livebook:{"output":true} -->

```
%File.Stat{
  size: 1915605,
  type: :regular,
  access: :read_write,
  atime: {{2023, 3, 7}, {8, 44, 48}},
  mtime: {{2023, 3, 7}, {8, 44, 48}},
  ctime: {{2023, 3, 7}, {8, 44, 48}},
  mode: 33261,
  links: 1,
  major_device: 16777231,
  minor_device: 0,
  inode: 18968372,
  uid: 502,
  gid: 20
}
```

Call a function of the newly updated Wasm binary. At this time, we get a correct result.

```elixir
new_result =
  worker_pid
  |> Wasmtube.Worker.call_function(
    :to_be_updated,
    data: %{
      values: values
    }
  )
```

<!-- livebook:{"output":true} -->

```
%{"mean" => 101, "median" => 108}
```
